* Zipfian moves for the MCMC adaptive integration

* Usage

running the script:
#+begin_src bash :results output
python levy_mcmc.py
#+end_src

calling the functions:
#+begin_src python :results output
from numpy import exp, array
from matplotlib import pyplot as plt
from scipy.stats import pearsonr, cauchy
from levy_mcmc import mcmc, prob_func

nb_el = 4
scale_val = 1.0
nb_steps = 100000

cauchy_gen = cauchy(scale=scale_val)
cauchy_step = lambda size: cauchy_gen.rvs(size=size)
traj, histo, x_dist = mcmc(nb_steps, nb_el, cauchy_step)

fig = plt.figure(1)
dens_f = [fig.add_subplot(int((nb_el+1) * 100 + 11 + i)) for i in range(nb_el+1)]
true_prob = array([prob_func(el) for el in x_dist])
true_prob /= sum(true_prob)

for i in range(nb_el):
    pred_prob = exp(histo[i, :])/sum(exp(histo[i, :]))
    print(pearsonr(pred_prob, true_prob))
    dens_f[i].plot(x_dist, pred_prob)
    dens_f[i].set_ylabel("density")
    dens_f[i].set_xlim([-20, 20])
    dens_f[i].tick_params(axis="x", labelbottom=False, size=0)
    # dens_f[i].hist(traj[:, i], bins=40)

dens_f[-1].plot(x_dist, true_prob)
dens_f[-1].set_xlim([-20, 20])
dens_f[-1].set_xlabel("Sample value")
dens_f[-1].set_ylabel("density")
plt.show()
#+end_src

#+RESULTS:
: (0.8920654688315222, 2.292282124354227e-139)
: (0.923118173691076, 2.7063456074570598e-167)
: (0.9067938761656608, 2.207363017592362e-151)
: (0.9160173533195017, 5.634094478258367e-160)
